local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")

local localPlayer = Players.LocalPlayer
local boxSize = Vector3.new(4, 5.5, 2)
local yOffset = (boxSize.Y / 2) - 2.75

local appliedESP = {}
local espVisible = true

-- Toggle ESP on/off
local function setESPVisibility(visible)
	espVisible = visible
	for _, player in pairs(Players:GetPlayers()) do
		if player ~= localPlayer then
			local character = player.Character
			if character then
				local espPart = character:FindFirstChild("FixedESPPart")
				if espPart then
					local box = espPart:FindFirstChildWhichIsA("SelectionBox")
					if box then
						box.Visible = visible
					end
				end
			end
		end
	end
end

-- Create ESP box for a character
local function createESP(character)
	if not character or character == localPlayer.Character then return end
	if character:FindFirstChild("FixedESPPart") then return end

	local root = character:FindFirstChild("HumanoidRootPart")
	if not root then return end

	local espPart = Instance.new("Part")
	espPart.Name = "FixedESPPart"
	espPart.Size = boxSize
	espPart.Anchored = true
	espPart.CanCollide = false
	espPart.Transparency = 1
	espPart.Parent = character

	local box = Instance.new("SelectionBox")
	box.Adornee = espPart
	box.Color3 = Color3.new(1, 1, 1) -- White
	box.LineThickness = 0.03
	box.SurfaceTransparency = 1
	box.Visible = espVisible
	box.Parent = espPart

	-- Update ESP position every frame
	RunService.RenderStepped:Connect(function()
		if character.Parent and root and espPart then
			espPart.CFrame = root.CFrame * CFrame.new(0, -yOffset, 0)
		end
	end)
end

-- Refresh ESP for all players every second
task.spawn(function()
	while true do
		for _, player in pairs(Players:GetPlayers()) do
			if player ~= localPlayer and not appliedESP[player] then
				player.CharacterAdded:Connect(function(character)
					task.wait(0.2)
					createESP(character)
				end)

				if player.Character then
					createESP(player.Character)
				end

				appliedESP[player] = true
			end
		end
		task.wait(1)
	end
end)

-- Listen for toggle key (T)
UserInputService.InputBegan:Connect(function(input, gameProcessed)
	if gameProcessed then return end
	if input.KeyCode == Enum.KeyCode.T then
		setESPVisibility(not espVisible)
	end
end)



--// Services
local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")

--// References
local localPlayer = Players.LocalPlayer
local camera = Workspace.CurrentCamera

--// Settings
local toggleKey = Enum.KeyCode.V
local fovToggleKey = Enum.KeyCode.B -- Toggle FOV circle visibility
local smoothness = 0.185 -- Range: 0 (slow) to 1 (instant snap)

-- FOV Circle Settings
local fovRadius = 250 -- in pixels
local fovColor = Color3.fromRGB(255, 255, 255)
local fovTransparency = 1
local fovThickness = 2

--// State
local isLocked = false
local targetHead = nil
local fovVisible = true

--// FOV Circle UI (requires Drawing API)
local fovCircle = Drawing.new("Circle")
fovCircle.Radius = fovRadius
fovCircle.Color = fovColor
fovCircle.Thickness = fovThickness
fovCircle.Transparency = fovTransparency
fovCircle.Filled = false
fovCircle.Visible = fovVisible

--// Get closest player head within FOV circle
local function getClosestHeadInView()
	local closestHead = nil
	local closestDistance = math.huge

	for _, player in pairs(Players:GetPlayers()) do
		if player ~= localPlayer and player.Character then
			local head = player.Character:FindFirstChild("Head")
			if head then
				local screenPos, onScreen = camera:WorldToViewportPoint(head.Position)
				if onScreen then
					local distanceFromCenter = (Vector2.new(screenPos.X, screenPos.Y) - camera.ViewportSize / 2).Magnitude
					if distanceFromCenter <= fovRadius and distanceFromCenter < closestDistance then
						closestDistance = distanceFromCenter
						closestHead = head
					end
				end
			end
		end
	end

	return closestHead
end

--// Input handling
UserInputService.InputBegan:Connect(function(input, processed)
	if processed then return end

	if input.KeyCode == toggleKey then
		if isLocked then
			isLocked = false
			targetHead = nil
		else
			local head = getClosestHeadInView()
			if head then
				targetHead = head
				isLocked = true
			end
		end
	elseif input.KeyCode == fovToggleKey then
		fovVisible = not fovVisible
		fovCircle.Visible = fovVisible
	end
end)

--// Update FOV Circle and Rotate Camera
RunService.RenderStepped:Connect(function()
	-- Update FOV circle position to center of screen
	fovCircle.Position = Vector2.new(camera.ViewportSize.X / 2, camera.ViewportSize.Y / 2)

	-- Camlock logic
	if isLocked and targetHead and targetHead:IsDescendantOf(Workspace) then
		local currentPos = camera.CFrame.Position
		local targetPos = targetHead.Position
		local targetLook = CFrame.new(currentPos, targetPos)

		local currentRotation = camera.CFrame - currentPos
		local targetRotation = targetLook - targetLook.Position
		local newRotation = currentRotation:Lerp(targetRotation, smoothness)

		camera.CFrame = CFrame.new(currentPos) * newRotation
	else
		if not targetHead or not targetHead:IsDescendantOf(Workspace) then
			isLocked = false
			targetHead = nil
		end
	end
end)





local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")

local localPlayer = Players.LocalPlayer
local desiredSpeed = 200 -- Speed when toggled ON
local normalSpeed = 16  -- Default WalkSpeed

local isSpeedOn = false -- Tracks toggle state

-- Function to apply the correct speed
local function updateWalkSpeed()
	local character = localPlayer.Character
	if not character then return end

	local humanoid = character:FindFirstChildOfClass("Humanoid")
	if not humanoid then return end

	humanoid.WalkSpeed = isSpeedOn and desiredSpeed or normalSpeed
end

-- Apply on character spawn
localPlayer.CharacterAdded:Connect(function()
	task.wait(0.1)
	updateWalkSpeed()
end)

-- Key press handler
UserInputService.InputBegan:Connect(function(input, gameProcessed)
	if gameProcessed then return end
	if input.KeyCode == Enum.KeyCode.E then
		isSpeedOn = not isSpeedOn
		updateWalkSpeed()
	end
end)

-- Initial apply
if localPlayer.Character then
	updateWalkSpeed()
end




